// Automaticaly generated by rust_swig
package xyz.ecumene.jgilrs;

//Represents handle to game controller.
//
//Using this struct you can access cached gamepad state, information about gamepad such as name or UUID and
//manage force feedback effects.
public final class Gamepad {

    private Gamepad() {}
    //@return the mapping name if it exists otherwise returns the os provided name.
    public final String getName()  {

        return do_getName(mNativeObj);
    }
    private static native String do_getName(long me) ;
    //@return if getMappingSource() is SdlMappings returns the name of the mapping used by the gamepad. Otherwise
    //returns nothing.
    public final String getMapName()  {

        return do_getMapName(mNativeObj);
    }
    private static native String do_getMapName(long me) ;
    //@return the name of the gamepad supplied by the OS.
    public final String getOSName()  {

        return do_getOSName(mNativeObj);
    }
    private static native String do_getOSName(long me) ;
    //@return cached gamepad state.
    public final GamepadState getState()  {

        return do_getState(mNativeObj);
    }
    private static native GamepadState do_getState(long me) ;
    //@return if gamepad is connected.
    public final boolean isConnected()  {

        return do_isConnected(mNativeObj);
    }
    private static native boolean do_isConnected(long me) ;
    //Examines cached gamepad state to check if given button is pressed. Panics if btn is Unknown.
    //If you know Code of the element that you want to examine, it's recommended to use methods directly on State,
    //because this version have to check which Code is mapped to element of gamepad.
    //@param btn - The button to poll
    public final boolean isPressed(Button a0)  {

        int a0C0 = a0.getValue();

        return do_isPressed(mNativeObj, a0C0);
    }
    private static native boolean do_isPressed(long me, int a0) ;
    //Examines cached gamepad state to check axis's value. Panics if axis is Unknown.
    //If you know Code of the element that you want to examine, it's recommended to use methods directly on State,
    //because this version have to check which Code is mapped to element of gamepad.
    //@param axis Axis - The axis to poll
    public final float getValue(Axis a0)  {

        int a0C0 = a0.getValue();

        return do_getValue(mNativeObj, a0C0);
    }
    private static native float do_getValue(long me, int a0) ;
    //Returns button state and when it changed.
    //
    //If you know Code of the element that you want to examine, it's recommended to use methods directly on State, because
    //this version have to check which Code is mapped to element of gamepad.
    //@parma btn - The button to get the data of
    public final java.util.Optional<ButtonData> getButtonData(Button a0)  {

        int a0C0 = a0.getValue();

        return do_getButtonData(mNativeObj, a0C0);
    }
    private static native java.util.Optional<ButtonData> do_getButtonData(long me, int a0) ;
    //Returns axis state and when it changed.
    //
    //If you know Code of the element that you want to examine, it's recommended to use methods directly on State, because
    //this version have to check which Code is mapped to element of gamepad.
    //@param axis - The axis to get the data of
    public final java.util.Optional<AxisData> getAxisData(Axis a0)  {

        int a0C0 = a0.getValue();

        return do_getAxisData(mNativeObj, a0C0);
    }
    private static native java.util.Optional<AxisData> do_getAxisData(long me, int a0) ;
    //@return device's power supply state. See PowerInfo for details.
    public final PowerInfo getPowerInfo()  {

        return do_getPowerInfo(mNativeObj);
    }
    private static native PowerInfo do_getPowerInfo(long me) ;
    //@returns if force feedback is supported by device.
    public final boolean isFFSupported()  {

        return do_isFFSupported(mNativeObj);
    }
    private static native boolean do_isFFSupported(long me) ;
    //@return area in which axis events should be ignored
    public final java.util.OptionalDouble getDeadzone(Code a0)  {

        long a0C0 = a0.mNativeObj;
        a0.mNativeObj = 0;

        return do_getDeadzone(mNativeObj, a0C0);
    }
    private static native java.util.OptionalDouble do_getDeadzone(long me, long a0) ;
    //@return ID of gamepad
    public final GamepadId getID()  {

        return do_getID(mNativeObj);
    }
    private static native GamepadId do_getID(long me) ;

    public synchronized void delete() {
        if (mNativeObj != 0) {
            do_delete(mNativeObj);
            mNativeObj = 0;
       }
    }
    @Override
    protected void finalize() throws Throwable {
        try {
            delete();
        }
        finally {
             super.finalize();
        }
    }
    private static native void do_delete(long me);
    /*package*/ long mNativeObj;
}